module JsonToElm.Gen exposing
    ( annotation
    , DecoderConfig, decoder
    , encoder, expression
    )

{-| Utilities for taking a `JsonValue` and generating code for it using
[elm-codegen](https://package.elm-lang.org/packages/mdgriffith/elm-codegen/latest/).

@docs annotation

@docs DecoderConfig, decoder

@docs encoder, expression

-}

import Dict exposing (Dict)
import Elm
import Elm.Annotation as Type
import Gen.Json.Decode
import Gen.Json.Encode
import Gen.Maybe
import Json.Encode
import JsonDecodeMapGen
import JsonToElm exposing (..)


{-| A configuration object when generating elm-codegen decoders.

The `decoderExpressionType` is an optional configuration for customizing how the expression generated by
the `decoder` function will be annotated. Providing an annotation will overwrite whatever annotation would
normally be generated.

-}
type alias DecoderConfig =
    { decoderExpressionType : Maybe Type.Annotation
    }


{-| Returns a `Elm.Expression` for use in elm-codegen.

For example, running the following code:

    toElmJsonValue (JsonString "test")

Will result in:

    Elm.string "test"

-}
expression : JsonValue -> Elm.Expression
expression value =
    case value of
        JsonInt int ->
            Elm.int int

        JsonFloat float ->
            Elm.float float

        JsonString string ->
            Elm.string string

        JsonBool bool ->
            Elm.bool bool

        JsonList list ->
            Elm.list (List.map expression list)

        JsonObject record ->
            Elm.record (List.map (\( key, val ) -> ( key, expression val )) (Dict.toList record))

        JsonNull ->
            Elm.nothing

        JsonUnknown unknown ->
            Elm.string (Json.Encode.encode 0 unknown)


{-| Returns a `Elm.Type.Annotation` for use in elm-codegen.

For example, running the following code:

    toAnnotation (StringVal "test")

Will result in:

    Elm.Annotation.string

-}
annotation : JsonValue -> Type.Annotation
annotation value =
    case value of
        JsonInt _ ->
            Type.int

        JsonFloat _ ->
            Type.float

        JsonString _ ->
            Type.string

        JsonBool _ ->
            Type.bool

        JsonList list ->
            Type.list
                (Maybe.withDefault Gen.Json.Encode.annotation_.value
                    (Maybe.map annotation (List.head list))
                )

        JsonObject record ->
            Type.record
                (List.map
                    (\( key, val ) -> ( key, annotation val ))
                    (Dict.toList record)
                )

        JsonNull ->
            {- todo -}
            Gen.Maybe.annotation_.maybe Type.string

        JsonUnknown _ ->
            Gen.Json.Encode.annotation_.value


{-| Returns a `Json.Decode` expression for use in elm-codegen.

For example, running the following code:

    toDecoder (StringVal "test")

Will result in:

    ( Gen.Json.Decode.string, Dict.empty )

**Note**: This function may also return a declaration for a custom `map` function if the passed `JsonValue` is
a record with more than 8 keys. When returned, this should be added to the generated code!

-}
decoder : DecoderConfig -> JsonValue -> ( Elm.Expression, Dict String Elm.Declaration )
decoder config passedJsonValue =
    toDecoderHelper config Dict.empty passedJsonValue


{-| A helper for `toDecoder` that does all of the work.
-}
toDecoderHelper :
    DecoderConfig
    -> Dict String Elm.Declaration
    -> JsonValue
    -> ( Elm.Expression, Dict String Elm.Declaration )
toDecoderHelper config accumulatedDeclarations passedJsonValue =
    let
        decodeJsonList passedList =
            Maybe.withDefault
                ( Gen.Json.Decode.value, accumulatedDeclarations )
                (Maybe.map (toDecoderHelper config accumulatedDeclarations)
                    (List.head passedList)
                )
    in
    case passedJsonValue of
        JsonInt _ ->
            ( Gen.Json.Decode.int
            , accumulatedDeclarations
            )

        JsonFloat _ ->
            ( Gen.Json.Decode.float
            , accumulatedDeclarations
            )

        JsonString _ ->
            ( Gen.Json.Decode.string
            , accumulatedDeclarations
            )

        JsonBool _ ->
            ( Gen.Json.Decode.bool
            , accumulatedDeclarations
            )

        JsonList list ->
            let
                ( listExpression, listDeclarations ) =
                    decodeJsonList list
            in
            ( Gen.Json.Decode.list listExpression
            , listDeclarations
            )

        JsonObject record ->
            let
                recordList =
                    Dict.toList record

                ( expressions, declarations ) =
                    Dict.foldr
                        (\key value ( expressionAcc, declarationAcc ) ->
                            let
                                functionName : String
                                functionName =
                                    "decode" ++ capitalizeFirstCharacter key

                                {- Gets the expression and declarations for the current value by recursively
                                   calling the `toDecoderHelper` function
                                -}
                                ( valueExpression, valueDeclarations ) =
                                    toDecoderHelper config declarationAcc value

                                combinedDeclarations : Dict String Elm.Declaration
                                combinedDeclarations =
                                    Dict.union declarationAcc valueDeclarations

                                {- Generates an expression from the current value being folded over.

                                   Checks the generated declarations and, if one matches the function being
                                   generated, returns an expression calling that function instead of a
                                   newly generated expression.
                                -}
                                generatedExpression : Elm.Expression
                                generatedExpression =
                                    Maybe.withDefault (Gen.Json.Decode.field key valueExpression)
                                        (Maybe.map
                                            (\_ ->
                                                Elm.value
                                                    { importFrom = []
                                                    , name = functionName
                                                    , annotation = Nothing
                                                    }
                                            )
                                            (Dict.get functionName combinedDeclarations)
                                        )
                            in
                            ( Dict.insert functionName generatedExpression expressionAcc
                            , combinedDeclarations
                            )
                        )
                        ( Dict.empty, accumulatedDeclarations )
                        record

                mapFunc =
                    JsonDecodeMapGen.generate (List.map Tuple.second (Dict.toList expressions))
            in
            {- Returns:
               - An expression for calling the decode function for this record
               - A dictionary of all the declrations that need to be added to the generated file
            -}
            ( Elm.withType
                (Maybe.withDefault (Gen.Json.Decode.annotation_.decoder (annotation passedJsonValue))
                    (Maybe.map Gen.Json.Decode.annotation_.decoder config.decoderExpressionType)
                )
                (mapFunc.call
                    (Elm.function
                        (List.map (Tuple.mapBoth ((++) "arg_") (annotation >> Just)) recordList)
                        (\exps ->
                            Elm.record (List.map2 (\( key, _ ) exp -> ( key, exp )) recordList exps)
                        )
                    )
                )
            , Dict.union mapFunc.declaration declarations
            )

        JsonNull ->
            ( Gen.Json.Decode.null Gen.Maybe.make_.nothing, accumulatedDeclarations )

        JsonUnknown _ ->
            ( Gen.Json.Decode.value, accumulatedDeclarations )


{-| Takes a `JsonToElm.JsonValue` and turns it into a `Json.Encode` expression.

For example, running the following code:

    toEncoder (StringVal "test")

Will result in:

    Gen.Json.Encode.call_.string

-}
encoder : JsonValue -> (Elm.Expression -> Elm.Expression)
encoder value =
    case value of
        JsonInt _ ->
            Gen.Json.Encode.call_.int

        JsonFloat _ ->
            Gen.Json.Encode.call_.float

        JsonString _ ->
            Gen.Json.Encode.call_.string

        JsonBool _ ->
            Gen.Json.Encode.call_.bool

        JsonList list ->
            Gen.Json.Encode.call_.list
                (Elm.functionReduced "a"
                    (Maybe.withDefault (\_ -> Gen.Json.Encode.string "failure")
                        (Maybe.map encoder (List.head list))
                    )
                )

        JsonObject record ->
            \passedRecord ->
                Gen.Json.Encode.object
                    (List.map
                        (\( k, val ) ->
                            Elm.tuple (Elm.string k) (encoder val (Elm.get k passedRecord))
                        )
                        (Dict.toList record)
                    )

        JsonNull ->
            \_ -> Gen.Json.Encode.null

        JsonUnknown _ ->
            \unknownVal ->
                Gen.Json.Encode.call_.string
                    (Gen.Json.Encode.encode 0 unknownVal)



{- Helpers -}


capitalizeFirstCharacter : String -> String
capitalizeFirstCharacter string =
    case String.uncons string of
        Just ( first, rest ) ->
            String.fromChar (Char.toUpper first) ++ rest

        Nothing ->
            string
